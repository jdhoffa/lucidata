name: Build and Test System

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build API service
        uses: docker/build-push-action@v4
        with:
          context: ./api
          push: false
          load: true
          tags: lucidata-api:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-llm-engine:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build LLM Engine service
        uses: docker/build-push-action@v4
        with:
          context: ./llm_engine
          push: false
          load: true
          tags: lucidata-llm-engine:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-query-runner:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Query Runner service
        uses: docker/build-push-action@v4
        with:
          context: ./query_runner
          push: false
          load: true
          tags: lucidata-query-runner:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  system-test:
    needs: [build-api, build-llm-engine, build-query-runner]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      # Save and load images from the build jobs
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Download the images built in the previous jobs
      - name: Download API image
        uses: docker/build-push-action@v4
        with:
          context: ./api
          load: true
          tags: lucidata-api:latest
          cache-from: type=gha
          outputs: type=docker,dest=/tmp/api-image.tar

      - name: Download LLM Engine image
        uses: docker/build-push-action@v4
        with:
          context: ./llm_engine
          load: true
          tags: lucidata-llm-engine:latest
          cache-from: type=gha
          outputs: type=docker,dest=/tmp/llm-engine-image.tar

      - name: Download Query Runner image
        uses: docker/build-push-action@v4
        with:
          context: ./query_runner
          load: true
          tags: lucidata-query-runner:latest
          cache-from: type=gha
          outputs: type=docker,dest=/tmp/query-runner-image.tar

      - name: Load saved images
        run: |
          docker load < /tmp/api-image.tar
          docker load < /tmp/llm-engine-image.tar
          docker load < /tmp/query-runner-image.tar
          docker images

      - name: Create empty .env file
        run: touch .env

      - name: Start services with docker compose
        run: |
          # Use the pre-built images instead of rebuilding
          docker compose up -d
        env:
          COMPOSE_DOCKER_CLI_BUILD: 0
          DOCKER_BUILDKIT: 1
          RUST_LOG: ${{ vars.RUST_LOG }}
          # Database variables
          POSTGRES_DB: ${{ vars.POSTGRES_DB }}
          POSTGRES_USER: ${{ vars.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          DATABASE_URL: "postgres://${{ vars.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/${{ vars.POSTGRES_DB }}"
          # API Service variables
          API_PORT: ${{ vars.API_PORT }}
          API_HOST: ${{ vars.API_HOST }}
          API_URL: ${{ vars.API_URL }}
          # LLM Engine variables
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLM_MODEL: ${{ vars.LLM_MODEL }}
          LLM_ENGINE_PORT: ${{ vars.LLM_ENGINE_PORT }}

      - name: Debug - Print Environment Variables
        run: |
          echo "=== Custom Variables ==="
          echo "RUST_LOG: ${{ vars.RUST_LOG }}"
          echo "POSTGRES_DB: ${{ vars.POSTGRES_DB }}"
          echo "POSTGRES_USER: ${{ vars.POSTGRES_USER }}"
          echo "DATABASE_URL: postgres://${{ vars.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/${{ vars.POSTGRES_DB }}"
          echo "API_PORT: ${{ vars.API_PORT }}"
          echo "API_HOST: ${{ vars.API_HOST }}"
          echo "API_URL: ${{ vars.API_URL }}"
          echo "LLM_MODEL: ${{ vars.LLM_MODEL }}"
          echo "LLM_ENGINE_PORT: ${{ vars.LLM_ENGINE_PORT }}"

      - name: Wait for services to be healthy
        run: |
          # Give services some time to start up
          echo "Waiting for services to start..."
          sleep 60
          
          # Check if API is healthy
          if curl -s http://localhost:8000/api/health > /dev/null; then
            echo "API is healthy"
          else
            echo "API health check failed"
            docker compose logs
            exit 1
          fi
          
          echo "All services are running properly!"

      - name: Stop services
        if: always() # Ensures this step runs even if previous steps fail
        run: docker compose down
